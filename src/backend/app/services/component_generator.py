"""
Component Generator Service

Generates Python component files for user-created agent components.
These files are placed in Langflow's custom_components directory
and appear in the sidebar after a Langflow restart.
"""
import os
import re
import logging
from datetime import datetime
from pathlib import Path
from typing import Tuple, Optional

from jinja2 import Environment, FileSystemLoader, TemplateError

logger = logging.getLogger(__name__)


class ComponentGeneratorError(Exception):
    """Exception raised when component generation fails."""
    pass


class ComponentGenerator:
    """
    Generates Python component files from AgentComponent records.

    When a user publishes an agent, this service:
    1. Loads the Jinja2 template
    2. Renders it with the agent's configuration
    3. Writes the Python file to custom_components/my_agents/
    4. Returns the file path and class name for storage

    The generated component mirrors Langflow's Agent component but with
    prefilled values from the user's Q&A answers.
    """

    # Default paths - can be overridden via environment variables
    TEMPLATE_DIR = Path(__file__).parent.parent.parent / "templates" / "component_templates"
    TEMPLATE_NAME = "user_agent_component.py.jinja2"

    def __init__(self, components_base_path: str = None):
        """
        Initialize the component generator.

        Args:
            components_base_path: Base path for custom components.
                                  Defaults to CUSTOM_COMPONENTS_PATH env var
                                  or ./custom_components
        """
        # Determine components directory
        self.components_base_path = Path(
            components_base_path or
            os.environ.get("CUSTOM_COMPONENTS_PATH", "./custom_components")
        )
        self.components_dir = self.components_base_path / "my_agents"

        # Set up Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.TEMPLATE_DIR)),
            trim_blocks=True,
            lstrip_blocks=True,
            keep_trailing_newline=True,
        )

        # Ensure directories exist
        self._ensure_directories()

    def _ensure_directories(self) -> None:
        """Ensure my_agents directory and __init__.py exist."""
        try:
            self.components_dir.mkdir(parents=True, exist_ok=True)

            init_file = self.components_dir / "__init__.py"
            if not init_file.exists():
                init_file.write_text('''"""
My Agents - Custom AI agent components generated by Teach Charlie AI.

These components are auto-generated from the 3-step Q&A wizard.
Each component appears in the Langflow sidebar under "My Agents"
and can be dragged into any workflow.

DO NOT EDIT THESE FILES MANUALLY - they will be regenerated when
the agent is republished from Teach Charlie AI.
"""
''')
                logger.info(f"Created __init__.py in {self.components_dir}")
        except OSError as e:
            logger.error(f"Failed to create components directory: {e}")
            raise ComponentGeneratorError(f"Cannot create components directory: {e}")

    def _sanitize_class_name(self, name: str, component_id: str) -> str:
        """
        Convert agent name to a valid Python class name.

        Args:
            name: Agent name (e.g., "Charlie the Car Salesman")
            component_id: UUID string for uniqueness

        Returns:
            Valid Python class name (e.g., "CharlieTheCarSalesmanAgent_abc12345")
        """
        # Remove special characters, keep only alphanumeric and spaces
        clean_name = re.sub(r'[^a-zA-Z0-9\s]', '', name)

        # Convert to PascalCase
        words = clean_name.split()
        pascal_name = ''.join(word.capitalize() for word in words if word)

        # Add "Agent" suffix and unique ID
        short_id = component_id[:8].replace('-', '')
        class_name = f"{pascal_name}Agent_{short_id}"

        # Ensure it starts with a letter
        if class_name and not class_name[0].isalpha():
            class_name = f"Agent_{class_name}"

        return class_name

    def _sanitize_file_name(self, name: str, component_id: str) -> str:
        """
        Convert agent name to a valid Python file name (snake_case).

        Args:
            name: Agent name
            component_id: UUID string for uniqueness

        Returns:
            Valid file name (e.g., "charlie_the_car_salesman_agent_abc12345.py")
        """
        # Remove special characters
        clean_name = re.sub(r'[^a-zA-Z0-9\s]', '', name)

        # Convert to snake_case
        words = clean_name.lower().split()
        snake_name = '_'.join(word for word in words if word)

        # Add unique ID
        short_id = component_id[:8].replace('-', '')

        return f"{snake_name}_agent_{short_id}"

    def generate_component(
        self,
        component_id: str,
        user_id: str,
        name: str,
        description: str,
        system_prompt: str,
        advanced_config: dict = None,
    ) -> Tuple[str, str]:
        """
        Generate a Python component file for an agent.

        Args:
            component_id: UUID of the AgentComponent
            user_id: UUID of the owner
            name: Agent name
            description: Agent description
            system_prompt: Generated system prompt from Q&A
            advanced_config: Dict with model settings (optional)

        Returns:
            Tuple of (file_path, class_name)

        Raises:
            ComponentGeneratorError: If generation fails
        """
        try:
            # Load template
            template = self.jinja_env.get_template(self.TEMPLATE_NAME)
        except TemplateError as e:
            raise ComponentGeneratorError(f"Failed to load template: {e}")

        # Generate class and file names
        class_name = self._sanitize_class_name(name, component_id)
        file_name = self._sanitize_file_name(name, component_id)

        # Merge advanced config with defaults
        config = {
            "model_provider": "OpenAI",
            "model_name": "gpt-4o-mini",
            "temperature": 0.7,
            "max_tokens": 4096,
            "max_iterations": 10,
            "verbose": False,
            "handle_parsing_errors": True,
            "chat_history_enabled": True,
        }
        if advanced_config:
            config.update(advanced_config)

        # Prepare template context
        context = {
            # Identity
            "agent_name": name,
            "class_name": class_name,
            "display_name": name,
            "description": description or f"AI Agent: {name}",

            # IDs
            "component_id": component_id,
            "user_id": user_id,
            "created_at": datetime.utcnow().isoformat(),

            # Core configuration (from Q&A)
            "system_prompt": system_prompt,

            # Advanced configuration
            "model_provider": config["model_provider"],
            "model_name": config["model_name"],
            "temperature": config["temperature"],
            "max_tokens": config["max_tokens"],
            "max_iterations": config["max_iterations"],
            "verbose": config["verbose"],
            "handle_parsing_errors": config["handle_parsing_errors"],
        }

        # Render template
        try:
            content = template.render(**context)
        except TemplateError as e:
            raise ComponentGeneratorError(f"Failed to render template: {e}")

        # Write file
        file_path = self.components_dir / f"{file_name}.py"
        try:
            file_path.write_text(content, encoding='utf-8')
            logger.info(f"Generated component file: {file_path}")
        except OSError as e:
            raise ComponentGeneratorError(f"Failed to write component file: {e}")

        # Return relative path (for storage in DB) and class name
        relative_path = str(file_path.relative_to(self.components_base_path.parent))

        return relative_path, class_name

    def delete_component(self, file_path: str) -> bool:
        """
        Delete a component file.

        Args:
            file_path: Path to the component file (can be relative or absolute)

        Returns:
            True if file was deleted, False if it didn't exist
        """
        # Handle both relative and absolute paths
        if os.path.isabs(file_path):
            full_path = Path(file_path)
        else:
            # Assume relative to project root
            full_path = Path(file_path)
            if not full_path.exists():
                # Try relative to components base
                full_path = self.components_base_path.parent / file_path

        if full_path.exists():
            try:
                full_path.unlink()
                logger.info(f"Deleted component file: {full_path}")
                return True
            except OSError as e:
                logger.error(f"Failed to delete component file: {e}")
                return False
        else:
            logger.warning(f"Component file not found for deletion: {full_path}")
            return False

    def component_exists(self, file_path: str) -> bool:
        """
        Check if a component file exists.

        Args:
            file_path: Path to the component file

        Returns:
            True if file exists
        """
        if os.path.isabs(file_path):
            return Path(file_path).exists()

        full_path = self.components_base_path.parent / file_path
        return full_path.exists()

    def validate_generated_component(self, file_path: str) -> Tuple[bool, Optional[str]]:
        """
        Validate that a generated component file is syntactically correct Python.

        Args:
            file_path: Path to the component file

        Returns:
            Tuple of (is_valid, error_message)
        """
        if os.path.isabs(file_path):
            full_path = Path(file_path)
        else:
            full_path = self.components_base_path.parent / file_path

        if not full_path.exists():
            return False, f"File not found: {full_path}"

        try:
            content = full_path.read_text(encoding='utf-8')
            compile(content, str(full_path), 'exec')
            return True, None
        except SyntaxError as e:
            return False, f"Syntax error: {e}"
        except Exception as e:
            return False, f"Validation error: {e}"


# Singleton instance for convenience
_generator_instance = None


def get_component_generator() -> ComponentGenerator:
    """Get or create the singleton ComponentGenerator instance."""
    global _generator_instance
    if _generator_instance is None:
        _generator_instance = ComponentGenerator()
    return _generator_instance
